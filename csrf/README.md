# уязвимость/атака

## Описание

CSRF - подделка межсайтовых запросов, другими словами, это атака при которой хакер выполняет массу различных действий от имени других, зарегистрированных посетителей.

Атаки по подделке межсайтовых запросов (CSRF) происходит в два этапа:
1) Необходимо заставить жертву щелкнуть по ссылке или загрузить страницу злоумышленника. Эта ссылка запускает поддельный запрос, содержащий вредоносный код. Вредоносный код обычно размещается на веб-сайте принадлежащим злоумышленнику, в другом домене.
  

2) Необходимо отправить специально созданный запрос в браузер жертвы, который отправит законный запрос в веб-приложение (JavaScript вызывает form.submit, отправляя таким образом форму на mail.com). Запрос будет отправлен со значениями, которые хочет злоумышленник, включая любые файлы cookie, которые жертва связала с этим веб-сайтом. Таким образом, веб-приложение знает, что эта жертва может выполнять определенные действия на веб-сайте, и любой запрос, отправленный с использованием этих учетных данных HTTP или файлов cookie, будет считаться законным, даже если жертва будет отправлять запрос по команде злоумышленника.


## Классификация
Пример атаки CSRF с использованием запроса GET
Пример, который будет описан в этом разделе, довольно прост и не обязательно отражает реальный пример, однако он служит хорошим примером, чтобы показать, как работают атаки CSRF.

GET-запросы по своей природе должны быть идемпотентными, что означает, что они не должны использоваться для выполнения изменений состояния, поэтому отправка GET-запроса не должна изменять никаких данных. Конечно, некоторые веб-приложения все еще используют GET вместо более подходящего POST для выполнения изменений состояния для таких операций, как изменение пароля или добавление пользователя.

При щелчке вредоносной ссылки, о которой мы упоминали ранее, злоумышленник может направить жертву в свое собственное вредоносное веб-приложение, которое выполнит сценарий, который, в свою очередь, заставит браузер жертвы отправить незаконный запрос. Этот запрос определен как незаконный, поскольку жертва не знает о том, что он отправляется, даже если он выглядит на веб-сервере так, как если бы пользователь отправил его, поскольку он включает в себя необходимые файлы cookie, необходимые веб-серверу для проверки того, что жертва кто они говорят, что они есть.

Представьте себе, если www.example.com обрабатывает переводы средств с помощью запроса GET, который будет включать два параметра: сумму, которую необходимо перевести, и идентификатор счета, на который будут переведены деньги. В приведенном ниже примере показан допустимый URL-адрес, который потребует, чтобы веб-приложение перевело 100 000 единиц соответствующей валюты на счет Фреда.

http://example.com/transfer?amount=1000000&account=Fred
Запрос будет включать в себя Cookie для аутентифицированного пользователя, поэтому нет необходимости определять, с какого счета будут переводиться деньги. Это означает, что если обычный пользователь получит доступ к этому URL-адресу, он должен будет пройти аутентификацию, поэтому веб-приложение будет знать, с какого счета будут сняты средства. Теперь, когда мы знаем, как этот запрос может быть использован по законным причинам, мы можем найти способ обмануть жертву в отправке запроса, который хочет атакующий, при этом аутентифицируясь как жертва.

Если эксплуатируемое веб-приложение ожидает GET-запрос, злоумышленник может добавить на свой веб-сайт тег, который вместо ссылки на изображение отправит запрос в веб-приложение банка:

<img src = "http://example.com/transfer?amount=1000000&account=Fred" />
Браузер при нормальных обстоятельствах автоматически отправляет файлы cookie, связанные с этим веб-приложением, что позволяет жертве изменять состояние от имени злоумышленника, когда изменение состояния представляет собой перевод средств.

CSRF-атаки с использованием запросов POST
Хотя эта атака работает на запросы GET значительно проще, злоумышленники также могут использовать метод POST для отправки запросов. Фактически, большинство запросов на изменение состояния будут выполняться через запросы POST, которые будут отправлять любые параметры и значения в теле запроса, а не сам URL, как в запросе GET. Это означает, что эксплуатируемые веб-приложения с большей вероятностью будут принимать запросы POST, а не GET, когда происходит изменение состояния.

Обманить жертву в отправку запроса POST может быть немного сложнее, чем отправить запрос GET. С помощью запроса GET злоумышленнику требовалось, чтобы жертва только отправила запрос, содержащий всю необходимую информацию в URL-адресе, тогда как для запросов POST требуется, чтобы тело запроса было добавлено к запросу. Используя немного JavaScript, злоумышленник может заманить жертву в свое вредоносное веб-приложение, чтобы при загрузке веб-страницы незаконный запрос POST отправлялся автоматически.

Возьмите следующий пример, используя функцию onload, которая автоматически отправит запрос из браузера жертвы, как только страница загрузится. Давайте возьмем следующий пример:

<body onload="document.csrf.submit()">
 
<form action="http://example.com/transfer" method="POST" name="csrf">
	<input type="hidden" name="amount" value="1000000">
	<input type="hidden" name="account" value="Fred">
</form>
Как только страница загружается, функция onload обеспечивает отправку формы с именем csrf, которая в свою очередь отправляет запрос POST. Взглянув на форму csrf, мы видим, что она включает два параметра и их значения, которые были статически установлены злоумышленником, где example.com идентифицирует запрос как законный, поскольку он будет включать файлы cookie жертвы.

Это не единственный способ выполнить эту атаку. Злоумышленник также может использовать iframe, атрибуты которого будут установлены, чтобы сделать его невидимым. Используя ту же функцию загрузки, злоумышленник может загрузить iframe своего вредоносного веб-приложения и, как только загрузится iframe, запрос будет отправлен.и

## Условия
- ОС: если проблема специфична для определенной ОС
- язык: если проблема специфичная для определенных языков
- компоненты: какие компоненты подвержены проблеме. Это могут быть библиотеки, базы данных, фреймворки, брокеры очередей и т.д.
- настройки: может есть какие-то специфичные настройки

Можно добавить еще информацию, которая не подходит под пункты выше, самостоятельно

## Детектирование
Описать как проблема детектируется. На что обращают внимание. Можно ли проблему детектировать автоматизированно или только вручную.
Если автоматизированно, то как лучше детектировать - код ревью или сканирование уязвимостей?

Информация:
- в каждый пункт можно добавлять необходимую информацию из статей в ввиде ссылок - [google.com](https://www.google.com)

## Эксплуатация
Здесь необходимо описать пример ручной эксплуатации. Сразу уточните какой это язык, какие компоненты используются, если эксплуатация специфична только для этих условий. Можно записать сюда порядок действий при эксплуатации тестового задания

### Инструменты
- здесь можно перечислить ссылками инструменты и полезную информацию, которая может понадобиться для эксплуатации

## Ущерб
Описать во что возможно развитие вектора атаки, если не существует защитных мер вовсе. То есть описать, что максимльно может получить злоумышленник, если все условия сойдутся.

Написать, к чему могут привести в итоге эксплуатация этих векторов атак

## Защита
### Основные меры
В основных мерах описываем способы как 100% защититься от уязвимости/атаки

### Превентивные меры
А здесь описываем как можем уменьшить ущерб от уязвимости/атаки, если она существует. То есть, подход Defense in Depth.

## Дополнительно
Здесь приложить дополнительную информацию и источники, которые использовали, но не указали выше в других местах.

## Обход защиты
Если существуют варианты обхода защиты, то можно их здесь перечислить.

Если есть возможность, то надо написать в чем заключается защита и каким образом она обходится.
