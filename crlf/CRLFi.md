# CRLF

## Описание
CRLF-injection представляет собой тип атаки, использующий давно известную уязвимость. Данная уязвимость представляет собой возможность добавления злоумышленниками через пользовательский ввод новых заголовков в ответ HTTP-сервера с использованием символа переноса строки (%0d%0a). Ведь сервер отделяет заголовки друг от друга, используя CRLF (Carriage Return/Line Feed)
Самый простой способ применения данной атаки - внедрение дополнительных заголовков в ответ от сервера, например, в web-приложении (собственно именно в них чаще данные атаки и используются).
Атака предназначена для обмана браузера клиента с использованием добавленных или измененных данных с целью проведения дальнейших махинаций.




## Условия
- ОС: данная уязвимость реализуема на любой ОС
- язык: ограничений нет
- компоненты: веб-сервер
- настройки: в специфических настройках необходимости нет

## Детектирование
Проверить наличие данной уязвимости довольно просто: добавлять при каждом пользовательском вводе символ переноса строки (%0d%0a) и, к примеру, заголовок Set-Cookie. Далее можем просмотреть ответ HTTP-сервера и если добавился cookie, то это свидетельствует о наличии уязвимости.


## Эксплуатация
Чтобы эксплуатировать CRLF-инъекцию необходимо в пользовательский ввод, который отражается в ответе, ввести запрашиваемую информацию вместе с символом переноса строки и последующим заголовком, который необходимо внедрить в ответ HTTP-сервера. Например, Set-Cookie.


*Добавление cookie*

Для выполнения данной операции введем в заголовке следующее:
%0D%0ASet-Cookie:crlf_team=tanya_masha_denis_edik

[https://github.com/karpuna3/shift2019/blob/master/crlf/1.png?raw=true]
Рисунок 1. Запрос и ответ с добавление cookie


Рисунок 2. Результат CRLF-инъекции с добавлением cookie

*Получение XSS*

Для достижения данной цели делаем все то же самое, что и в пункте 1 с той оговоркой, что необходимо после символа переноса строки использовать иные заголовки
12%0d%0aContent-Length%3A35%0d%0aX-XSS-Protection%3A0%0d%0a%0d%0a23%0d%0a%3Csvg%20onload%3Dalert%28document.domain%29%3E%0d%0a0%0d%0a%2F%2f%2e%2e


Рисунок 3. Реализации CRLF-инъекции для XSS



Рисунок 4. Результат получения XSS


*Замена информации полученной пользователем*

Рисунок 5. Информация, которую получает пользователь до подмены.

Меняем заголовок: %0d%0aContent-Length:35%0d%0aX-XSS-Protection:0%0d%0a%0d%0aYou are hacked%0d%0a<svg%20onload=alert(document.domain)>%0d%0a0%0d%0a/%2f%2e%2e


Рисунок 6. Процесс подмены информации






## Ущерб
Данный тип атаки позволяет фальсифицировать данные в ответе от веб-сервера, добавлять cookie или даже отключать XSS-защиту для последующей более опасной атаки.
Также исследуемая атака может открыть брешь для иных атак:
- XSS, которая возможно приведет к краже сессии
- Session Fixation
- Open Redirect
- Обход Stateless-защиты от CSRF - проверка сервером значения cookie и заголовка
- Proxy and web server cache poisoning
- Client web browser poisoning

Также стоит отметить тот факт, что CRLF может использоваться для фишинга.

## Защита
### Основные меры
Лучший метод предотвращения - не позволять пользователям вводить данные непосредственно в заголовки ответов. Если это невозможно, всегда следует использовать функцию для кодирования специальных символов CR и LF. Также рекомендуется обновить язык программирования до версии, которая не позволяет вводить CR и LF в функции, задающие заголовки.
Также для защиты от такого типа атак следует использовать более новые версии языков программирования, которые имеют встроенную защиту от CRLF-инъекций.
Лучшим способом устранения уязвимостей разделения ответов HTTP является поиск во всех введенных пользователями данных символов CR/LF, т.е, \r\n, %0d%0a или любой другой формы их кодирования (или других небезопасных символов) перед использованием этих данных в любых заголовках HTTP.


### Превентивные меры
В случае если есть подозрение на CRLF инъекцию, можно попробовать отфильтровать все CRLF символы внесенные пользователями. Также стоит ограничить ввод пользователей и редактирование URL -адреса.
 

